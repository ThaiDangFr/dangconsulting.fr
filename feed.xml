<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="fr"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://dangconsulting.fr/feed.xml" rel="self" type="application/atom+xml"/><link href="https://dangconsulting.fr/" rel="alternate" type="text/html" hreflang="fr"/><updated>2024-07-03T19:55:20+00:00</updated><id>https://dangconsulting.fr/feed.xml</id><title type="html">Cloud ∞ DevOps</title><subtitle>Blog sur les sujets liés à la tech </subtitle><entry><title type="html">TLS PKI sidecar container</title><link href="https://dangconsulting.fr/blog/2024/pki-sidecar-tls/" rel="alternate" type="text/html" title="TLS PKI sidecar container"/><published>2024-07-03T12:00:00+00:00</published><updated>2024-07-03T12:00:00+00:00</updated><id>https://dangconsulting.fr/blog/2024/pki-sidecar-tls</id><content type="html" xml:base="https://dangconsulting.fr/blog/2024/pki-sidecar-tls/"><![CDATA[<h1 id="introduction">Introduction</h1> <p>Dans cet article, nous allons voir comment configurer un sidecar container pour gérer le TLS en utilisant le secret engine PKI de Vault. Contrairement au <a href="/blog/2024/sidecar-tls">sidecar TLS simple</a>, nous allons faire de sorte que les certificats se renouvellent automatiquement sans interruption de service.</p> <p>Notre Pod va contenir :</p> <ul> <li>un serveur web qui répond “hello world” sur le port 80</li> <li>un sidecar qui va gérer le TLS sur le port 443 avec des certificats téléchargés depuis Vault</li> <li>un sidecar Vault Agent qui va télécharger les certificats et les maintenir à jour dans le volume Kubernetes</li> </ul> <p>Nous allons utiliser un Vault avec le <a href="/blog/2024/vault-pki">secret engine PKI activé et configuré</a>.</p> <p>Lorsqu’un certificat est généré à l’aide de la fonction de modèle <code class="language-plaintext highlighter-rouge">pkiCert</code>, le modèle de Vault Agent adopte les comportements suivants pour la récupération et la réémission des certificats :</p> <ul> <li>il récupère un nouveau certificat au démarrage de l’Agent s’il n’en a pas déjà généré un précédemment ou si le certificat actuellement généré a expiré</li> <li>lors d’une ré-authentification automatique de l’Agent (par exemple, en cas d’expiration du jeton), il ne récupère pas de nouveau certificat à moins que le certificat actuellement généré ait expiré</li> </ul> <h1 id="configuration-de-vault">Configuration de Vault</h1> <p>Nous allons configurer Vault afin d’activer l’authentification Kubernetes.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">SA_CA_CRT</span><span class="o">=</span><span class="si">$(</span>kubectl config view <span class="nt">--raw</span> <span class="nt">--minify</span> <span class="nt">--flatten</span> <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">={</span>.clusters[].cluster.certificate-authority-data<span class="o">}</span> | <span class="nb">base64</span> <span class="nt">-d</span><span class="si">)</span>

vault auth <span class="nb">enable </span>kubernetes

vault write auth/kubernetes/config <span class="se">\</span>
     <span class="nv">disable_local_ca_jwt</span><span class="o">=</span><span class="s2">"true"</span> <span class="se">\</span>
     <span class="nv">kubernetes_host</span><span class="o">=</span><span class="s2">"https://192.168.0.20:6443"</span> <span class="se">\</span>
     <span class="nv">kubernetes_ca_cert</span><span class="o">=</span><span class="s2">"</span><span class="nv">$SA_CA_CRT</span><span class="s2">"</span> <span class="se">\</span>
     <span class="nv">issuer</span><span class="o">=</span><span class="s2">"https://kubernetes.default.svc.cluster.local"</span>

vault <span class="nb">read </span>auth/kubernetes/config

vault write auth/kubernetes/role/authkube <span class="se">\</span>
     <span class="nv">bound_service_account_names</span><span class="o">=</span>app-sa <span class="se">\</span>
     <span class="nv">bound_service_account_namespaces</span><span class="o">=</span>poc-sidecar-tls-pki <span class="se">\</span>
     <span class="nv">token_policies</span><span class="o">=</span>pki <span class="se">\</span>
     <span class="nv">ttl</span><span class="o">=</span>24h
</code></pre></div></div> <h1 id="configuration-de-kubernetes">Configuration de Kubernetes</h1> <h2 id="création-du-namespace">Création du namespace</h2> <p>ns.yaml</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Namespace</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">poc-sidecar-tls-pki</span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> ns.yaml
kubectl config set-context <span class="nt">--current</span> <span class="nt">--namespace</span><span class="o">=</span>poc-sidecar-tls-pki
</code></pre></div></div> <h2 id="déploiement-des-configmaps">Déploiement des configmaps</h2> <p>cm-agent-sidecar.yaml : contient la configuration du vault agent qui va permettre de maintenir l’authentification à Vault et obtenir les fichiers tls.crt et tls.key pour le domaine foo.home</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ConfigMap</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">agent-sidecar-cm</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">poc-sidecar-tls-pki</span>
<span class="na">data</span><span class="pi">:</span>
  <span class="na">vault-agent-config.hcl</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s"># Comment this out if running as sidecar instead of initContainer</span>
    <span class="s">exit_after_auth = false</span>

    <span class="s">pid_file = "/home/vault/pidfile"</span>

    <span class="s">auto_auth {</span>
        <span class="s">method "kubernetes" {</span>
            <span class="s">mount_path = "auth/kubernetes"</span>
            <span class="s">config = {</span>
                <span class="s">role = "authkube"</span>
            <span class="s">}</span>
        <span class="s">}</span>

        <span class="s">sink "file" {</span>
            <span class="s">config = {</span>
                <span class="s">path = "/home/vault/.vault-token"</span>
            <span class="s">}</span>
        <span class="s">}</span>
    <span class="s">}</span>


    <span class="s">template {</span>
    <span class="s">destination = "/etc/nginx/ssl/tls.crt"</span>
    <span class="s">contents = &lt;&lt;EOT</span>
    
    
    
    
    <span class="no">    </span>
    <span class="s">EOT</span>
    <span class="s">perms = 0644</span>
    <span class="s">}</span>
</code></pre></div></div> <p>cm-app.yaml : contient des variables d’environnement</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ConfigMap</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">app-cm</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">poc-sidecar-tls-pki</span>
<span class="na">data</span><span class="pi">:</span> 
  <span class="na">VAULT_ADDR</span><span class="pi">:</span> <span class="s2">"</span><span class="s">https://vault.home"</span>
  <span class="na">VAULT_CACERT</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/etc/ssl/certs/vault.pem"</span>
</code></pre></div></div> <p>cm-chain-ca.yaml : contient les certificats Intermediate CA et Root CA concaténés ensemble</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ConfigMap</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">chain-ca-cm</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">poc-sidecar-tls-pki</span>
<span class="na">data</span><span class="pi">:</span>
  <span class="na">vault.pem</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">-----BEGIN CERTIFICATE-----</span>
    <span class="s">MIIC7DCCApKgAwIBAgIUPtQcuNvBFdJzqo3AoRFgOSsiaG4wCgYIKoZIzj0EAwIw</span>
    <span class="s">LDEYMBYGA1UEChMPRGFuZyBDb25zdWx0aW5nMRAwDgYDVQQDEwdSb290IENBMB4X</span>
    <span class="s">DTI0MDYxOTEyMjgzOVoXDTI5MDYxODEyMjkwOVowGjEYMBYGA1UEAxMPSW50ZXJt</span>
    <span class="s">ZWRpYXRlIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvP/UEhbp</span>
    <span class="s">4OCr9tzSJw3h8GtaZpXCel6raybntq66uZwGTMbWFqUdFqTzBca+5EJgkz7cGLse</span>
    <span class="s">h4zJu0JYFB1cE0NFzyMaonVdv5T1cLjvoiklzZcVQrC8XQrImasT8Z3qgoZRLQ79</span>
    <span class="s">emed0ubafaKxRn+0srTmFZEQ8ANguFLyQI6XqI4n/9wy5JKJK8y6iAMCzidkx2+r</span>
    <span class="s">pCYzeS0CkiFTV9wbB89haspZdPOeB/4oJuZiMotBd+lav5P4DzCfT+Zy7donJtcB</span>
    <span class="s">91+SvOeDMmhKR/Ruir+1sFYXDPMq+gVf9hjavuDu82ylF+D2Vpz4VQ/WA8DzlP/4</span>
    <span class="s">5yK/K8P9zRDBBwIDAQABo4HYMIHVMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E</span>
    <span class="s">BTADAQH/MB0GA1UdDgQWBBTqnRa/wFhgeQCNyptE7c3LHVOKWDAfBgNVHSMEGDAW</span>
    <span class="s">gBRkw7RXwBwEJ/UsgMkz6qRiVvPVhTA9BggrBgEFBQcBAQQxMC8wLQYIKwYBBQUH</span>
    <span class="s">MAKGIWh0dHBzOi8vdmF1bHQuaG9tZS92MS9wa2lfcm9vdC9jYTAzBgNVHR8ELDAq</span>
    <span class="s">MCigJqAkhiJodHRwczovL3ZhdWx0LmhvbWUvdjEvcGtpX3Jvb3QvY3JsMAoGCCqG</span>
    <span class="s">SM49BAMCA0gAMEUCIQCh7DpEdllzu/1+HITWQdTbOOfJ7IDe6i/n8lCRniRqeAIg</span>
    <span class="s">LJTfEaxnbER0Qm+Mb4JB0yINqesGzsIdKoLCzp9dUas=</span>
    <span class="s">-----END CERTIFICATE-----</span>
    <span class="s">-----BEGIN CERTIFICATE-----</span>
    <span class="s">MIIBmzCCAUGgAwIBAgIRAPz9FOe+IXCzfMCkQu5ImUcwCgYIKoZIzj0EAwIwLDEY</span>
    <span class="s">MBYGA1UEChMPRGFuZyBDb25zdWx0aW5nMRAwDgYDVQQDEwdSb290IENBMCAXDTIz</span>
    <span class="s">MTEyNzExMTgyMloYDzIxMjMxMTI4MTExODIyWjAsMRgwFgYDVQQKEw9EYW5nIENv</span>
    <span class="s">bnN1bHRpbmcxEDAOBgNVBAMTB1Jvb3QgQ0EwWTATBgcqhkjOPQIBBggqhkjOPQMB</span>
    <span class="s">BwNCAAR5BP2rtk2YImzxHBQPnsvvAk7b5HetisGtIu6rtfy3I6Q98pgVOq3PVyCY</span>
    <span class="s">Y3KR4mZWosAjaeOS/rK0W40YgxiSo0IwQDAOBgNVHQ8BAf8EBAMCAqQwDwYDVR0T</span>
    <span class="s">AQH/BAUwAwEB/zAdBgNVHQ4EFgQUZMO0V8AcBCf1LIDJM+qkYlbz1YUwCgYIKoZI</span>
    <span class="s">zj0EAwIDSAAwRQIgDdrAKVlOaZY1LIQqJJnaiBIxVtiVb8hcIWQZfb91CscCIQC/</span>
    <span class="s">PY73ybZ9VbmIskEy59C8VRQdsUA6JocIUlEfTZHQJg==</span>
    <span class="s">-----END CERTIFICATE-----   </span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> cm-agent-sidecar.yaml,cm-app.yaml,cm-chain-ca.yaml
</code></pre></div></div> <h2 id="création-du-service-account-et-du-jwt-associé">Création du Service Account et du JWT associé</h2> <p>Un Service Account représente une identité pour un Pod. Le JWT associé au service account va contenir 2 informations qui vont permettre à Vault d’authentifier le Pod : le nom du Namespace et le nom du Service Account</p> <p>secret.yaml</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Secret</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">app-secret</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">poc-sidecar-tls-pki</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="na">kubernetes.io/service-account.name</span><span class="pi">:</span> <span class="s">app-sa</span>
<span class="na">type</span><span class="pi">:</span> <span class="s">kubernetes.io/service-account-token</span>
</code></pre></div></div> <p>sa.yaml</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ServiceAccount</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">app-sa</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">poc-sidecar-tls-pki</span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> secret.yaml,sa.yaml
</code></pre></div></div> <h2 id="affectation-des-permissions-au-service-account">Affectation des permissions au Service Account</h2> <p>Pour définir des permissions pour un service account, on utilise :</p> <ul> <li>un Role (objet “RoleBindings”) pour un namespace particulier</li> <li>ou ClusterRole (objet “ClusterRoleBinding”) pour tout le cluster</li> </ul> <p>crb.yaml</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">rbac.authorization.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterRoleBinding</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">app-crb</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">poc-sidecar-tls-pki</span>
<span class="na">roleRef</span><span class="pi">:</span>
  <span class="na">apiGroup</span><span class="pi">:</span> <span class="s">rbac.authorization.k8s.io</span>
  <span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterRole</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">system:auth-delegator</span>
<span class="na">subjects</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">kind</span><span class="pi">:</span> <span class="s">ServiceAccount</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">app-sa</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">poc-sidecar-tls-pki</span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> crb.yaml

<span class="c"># check</span>
kubectl describe clusterrolebinding.rbac.authorization.k8s.io/app-crb
</code></pre></div></div> <h1 id="troubleshooting">Troubleshooting</h1> <h2 id="vérification-que-le-cluster-à-les-droits-pour-inspecter-le-jwt">Vérification que le cluster à les droits pour inspecter le JWT</h2> <p>pour rappel, ces droits sont accordés dans crb.yaml</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get clusterrole system:auth-delegator <span class="nt">-o</span> yaml

<span class="nv">jwt</span><span class="o">=</span><span class="si">$(</span>kubectl get secrets app-secret <span class="nt">-o</span> json | jq <span class="nt">-r</span> <span class="s1">'.data.token'</span> | <span class="nb">base64</span> <span class="nt">-d</span><span class="si">)</span>

<span class="nb">tee </span>tokenreview.yaml <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
kind: TokenReview
apiVersion: authentication.k8s.io/v1
metadata:
  name: test
spec:
  token: </span><span class="nv">$jwt</span><span class="sh">
</span><span class="no">EOF

</span><span class="c"># should return a yaml with authenticated: true</span>
kubectl apply <span class="nt">-o</span> yaml <span class="nt">-f</span> tokenreview.yaml
</code></pre></div></div> <h2 id="vérification-que-le-jwt-permet-bien-de-sauthentifier-à-vault">Vérification que le JWT permet bien de s’authentifier à Vault</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># JWT is in token field </span>
kubectl describe secret app-secret

<span class="c"># =&gt; should respond with a json with the client_token</span>
curl <span class="nt">--request</span> POST <span class="nt">--data</span> <span class="s1">'{"jwt": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjZIb2M2RnVUSy12TlhqYzJ3VnE4MkVfeDFQaFNQdTlpUkR5NjdyZTlTUGMifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJwb2Mtc2lkZWNhci10bHMtcGtpIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImFwcC1zZWNyZXQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiYXBwLXNhIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiZGVjZTE0MzAtYzZkOC00NDUzLWE2YzQtNjFiYzY5MzA5ZTRlIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50OnBvYy1zaWRlY2FyLXRscy1wa2k6YXBwLXNhIn0.Gil1a32Yyleibo4PyBQ2rTDnjNXs7rA10r7EhyQbirIt2wGZNz6Xbypl3akYWL-9cKaqNUrSxw9rnapRue6TXjN0lzxDSNT3ZcdwzxImNl_wdc7SuCGmYWYrgKMvgLQQlbCKMRUwDl18sImCbsAv06Bu3Kwv3jpgerTeiU3KaFZXhuTDmwUWAuPN6SooQNJW0BRkjlLTTYpHsQT28fyBbGWBj5jLqDADqOsP926_iv3HaIJ22LYABy5eaIIt4K9QizCE7Io8QF2orf_RbZuQea2xHgmVWk9MMrjhMplClq6b145asG6tpBUR7HwetrnyJTZaOKWmn2B2hbrsI9iVDw", "role": "authkube"}'</span> https://vault.home/v1/auth/kubernetes/login
</code></pre></div></div> <h2 id="vérification-que-tlskey-et-tlscrt-correspondent">Vérification que tls.key et tls.crt correspondent</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>troubleshooting
kubectl <span class="nb">cp </span>poc-sidecar-tls-pki-deploy-bc75b6b6-5966n:/etc/nginx/ssl/tls.key tls.key <span class="nt">-c</span> vault
kubectl <span class="nb">cp </span>poc-sidecar-tls-pki-deploy-bc75b6b6-5966n:/etc/nginx/ssl/tls.crt tls.crt <span class="nt">-c</span> vault

openssl pkey <span class="nt">-pubout</span> <span class="nt">-in</span> tls.key | openssl sha256  
SHA2-256<span class="o">(</span>stdin<span class="o">)=</span> ab1f1ed68ebd181ac3212c875fa4a107c1fc5ef81ec9301b259cfbb584df73f1

openssl x509 <span class="nt">-pubkey</span> <span class="nt">-in</span> tls.crt <span class="nt">-noout</span> | openssl sha256
SHA2-256<span class="o">(</span>stdin<span class="o">)=</span> ab1f1ed68ebd181ac3212c875fa4a107c1fc5ef81ec9301b259cfbb584df73f1
</code></pre></div></div> <h2 id="vérification-des-dates-dexpiration-des-certificats-en-se-connectant-au-container">Vérification des dates d’expiration des certificats en se connectant au container</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl <span class="nb">exec</span> <span class="nt">-it</span> deployment.apps/poc-sidecar-tls-pki-deploy <span class="nt">-c</span> nginx <span class="nt">--</span> bash

<span class="c"># manual check</span>
<span class="nb">echo</span> | openssl s_client <span class="nt">-showcerts</span> <span class="nt">-servername</span> foo.home <span class="nt">-connect</span> localhost:443 | openssl x509 <span class="nt">-noout</span> <span class="nt">-enddate</span>
<span class="nv">notAfter</span><span class="o">=</span>Jun 24 18:37:37 2024 GMT

<span class="c"># used by liveness (exit code 1 if expired)</span>
<span class="nb">echo</span> | openssl s_client <span class="nt">-showcerts</span> <span class="nt">-servername</span> foo.home <span class="nt">-connect</span> localhost:443 | openssl x509 <span class="nt">-noout</span> <span class="nt">-enddate</span> <span class="nt">-checkend</span> 0
</code></pre></div></div> <h1 id="références">Références</h1> <ul> <li><a href="https://www.hashicorp.com/blog/kubernetes-vault-integration-via-sidecar-agent-injector-vs-csi-provider">https://www.hashicorp.com/blog/kubernetes-vault-integration-via-sidecar-agent-injector-vs-csi-provider</a></li> <li><a href="https://developer.hashicorp.com/vault/docs/agent-and-proxy/agent/template">https://developer.hashicorp.com/vault/docs/agent-and-proxy/agent/template</a></li> <li><a href="https://developer.hashicorp.com/vault/tutorials/vault-agent/agent-env-vars">https://developer.hashicorp.com/vault/tutorials/vault-agent/agent-env-vars</a></li> <li><a href="https://support.hashicorp.com/hc/en-us/articles/4404389946387-Kubernetes-auth-method-Permission-Denied-error">https://support.hashicorp.com/hc/en-us/articles/4404389946387-Kubernetes-auth-method-Permission-Denied-error</a></li> <li><a href="https://wlwan.medium.com/why-a-cluster-role-binding-is-needed-in-k8s-vault-integration-82b5aefc4d81">https://wlwan.medium.com/why-a-cluster-role-binding-is-needed-in-k8s-vault-integration-82b5aefc4d81</a></li> <li><a href="https://www.hashicorp.com/blog/certificate-management-with-vault">https://www.hashicorp.com/blog/certificate-management-with-vault</a></li> </ul>]]></content><author><name></name></author><category term="education"/><category term="tls"/><category term="sidecar"/><category term="vault"/><category term="kubernetes"/><summary type="html"><![CDATA[Utiliser un sidecar pour gérer le TLS avec des certificats dynamiques Vault]]></summary></entry><entry><title type="html">fdupes</title><link href="https://dangconsulting.fr/blog/2024/fdupes/" rel="alternate" type="text/html" title="fdupes"/><published>2024-07-02T12:00:00+00:00</published><updated>2024-07-02T12:00:00+00:00</updated><id>https://dangconsulting.fr/blog/2024/fdupes</id><content type="html" xml:base="https://dangconsulting.fr/blog/2024/fdupes/"><![CDATA[<h1 id="fdupes-un-outil-pour-détecter-et-supprimer-les-fichiers-en-doublon">fdupes, un outil pour détecter et supprimer les fichiers en doublon</h1> <p>fupes est un outil permettant de faire le ménage dans vos fichiers en trouvant les doublons. On peut s’en servir pour faire le tri dans ses photos par exemple. L’algorithme se base sur un checksum donc les fichiers peuvent avoir n’importe quel nom ou extension, il trouvera les doublons de contenu.</p> <p>Exemple, pour lancer une recherche récursive dans le répertoire 2024 avec un prompt</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># option S pour afficher la SIZE, r pour RECURSIVE et d pour DELETE</span>
fdupes <span class="nt">-Srd</span> 2019
</code></pre></div></div> <p>Exemple de prompt suite à la découverte de doublon</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set 22 of 23:

    [+] 2019/vacances/BOPY5441.jpg
    [-] 2019/tmp/OGJG0828.jpg

Set 23 of 23:

  1 [+] 2019/vacances/DSC00170.JPG
  2 [-] 2019/tmp/DSC00170.JPG

( Preserve files [1 - 2, all, help] ): 
</code></pre></div></div> <p>Pour chaque entrée, on choisis lequel on veut conserver, par exemple sur l’entrée 22 et 23, j’ai choisis “1” donc il me conserve le 1 avec le signe “+”. A la fin pour exécuter le nettoyage, on appuie sur SUPPR”. Puis quand tout est fini, on appuie sur “q” pour sortir.</p> <p>Exemple pour lancer une recherche sans prompt de fin, et ne garder que le premier en cas de doublon</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># option N pour NO prompt</span>
fdupes <span class="nt">-rdN</span> 2013
</code></pre></div></div>]]></content><author><name></name></author><category term="education"/><category term="linux"/><summary type="html"><![CDATA[fdupes pour trouver les fichiers en doublon]]></summary></entry><entry><title type="html">TLS simple sidecar container</title><link href="https://dangconsulting.fr/blog/2024/sidecar-tls/" rel="alternate" type="text/html" title="TLS simple sidecar container"/><published>2024-06-21T12:00:00+00:00</published><updated>2024-06-21T12:00:00+00:00</updated><id>https://dangconsulting.fr/blog/2024/sidecar-tls</id><content type="html" xml:base="https://dangconsulting.fr/blog/2024/sidecar-tls/"><![CDATA[<h1 id="container-sidecar">Container sidecar</h1> <p>Le but d’un container sidecar est de rajouter des fonctionnalités au container principal au sein d’un Pod Kubernetes. On utilise ici la propriété qu’au sein d’un même Pod, les container peuvent utiliser les mêmes ressources réseau et stockage.</p> <h1 id="workshop-sidecar-tls-avec-une-paire-de-clef-créée-manuellement">Workshop sidecar TLS avec une paire de clef créée manuellement</h1> <h3 id="pré-requis">Pré-requis</h3> <p>ns.yaml</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Namespace</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">poc-sidecar-tls</span>
</code></pre></div></div> <p>création d’un namespace dédié</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> ns.yaml
kubectl config set-context <span class="nt">--current</span> <span class="nt">--namespace</span><span class="o">=</span>poc-sidecar-tls
</code></pre></div></div> <h3 id="container-a--un-serveur-web-sur-le-port-80">Container A : un serveur web sur le port 80</h3> <p>docker-nginx-hello-world/Dockerfile</p> <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> nginx:latest</span>
<span class="k">COPY</span><span class="s"> index.html /usr/share/nginx/html/index.html</span>
</code></pre></div></div> <p>docker-nginx-hello-world/index.html</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;&lt;title&gt;</span>Hello world<span class="nt">&lt;/title&gt;&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>Hello world<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div> <p>création et push de l’image</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>docker-nginx-hello-world
docker build <span class="nt">-t</span> thaidangfr/nginx-hello-world:v1.0 <span class="nb">.</span>
docker push thaidangfr/nginx-hello-world:v1.0
</code></pre></div></div> <h3 id="container-b--un-sidecar-tls-sur-le-port-443-qui-proxyfie-vers-le-port-80-et-donc-le-container-a">Container B : un sidecar tls sur le port 443 qui proxyfie vers le port 80 (et donc le container A)</h3> <p>docker-sidecar-nginx-tls/Dockerfile</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM nginx:latest
COPY default.conf /etc/nginx/conf.d/default.conf
</code></pre></div></div> <p>docker-sidecar-nginx-tls/default.conf</p> <div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>
    <span class="kn">ssl_certificate</span>       <span class="n">/etc/nginx/ssl/tls.crt</span><span class="p">;</span>
    <span class="kn">ssl_certificate_key</span>   <span class="n">/etc/nginx/ssl/tls.key</span><span class="p">;</span>
    <span class="kn">ssl_protocols</span>       <span class="s">TLSv1</span> <span class="s">TLSv1.1</span> <span class="s">TLSv1.2</span> <span class="s">TLSv1.3</span><span class="p">;</span>
    <span class="kn">ssl_ciphers</span>         <span class="s">HIGH:!aNULL:!MD5</span><span class="p">;</span>

    <span class="c1"># allow large body sizes</span>
    <span class="kn">client_max_body_size</span> <span class="mi">32m</span><span class="p">;</span>

    <span class="c1"># increase client body buffer for performance.</span>
    <span class="kn">client_body_buffer_size</span> <span class="mi">128k</span><span class="p">;</span>

    <span class="kn">ssl_session_cache</span> <span class="s">shared:SSL:20m</span><span class="p">;</span>

    <span class="kn">access_log</span> <span class="n">/dev/stdout</span><span class="p">;</span>
    <span class="kn">error_log</span> <span class="n">/dev/stdout</span> <span class="s">info</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="c1"># proxy to upstream application</span>
        <span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:80</span><span class="p">;</span>

        <span class="c1"># don't use http 1.0 so keepalive enabled by default</span>
        <span class="kn">proxy_http_version</span> <span class="mf">1.1</span><span class="p">;</span>

        <span class="c1"># prevent client from closing keepalive</span>
        <span class="kn">proxy_set_header</span> <span class="s">Connection</span> <span class="s">""</span><span class="p">;</span>

        <span class="c1"># if the proxied server does not receive anything within this time, the connection is closed</span>
        <span class="kn">proxy_send_timeout</span> <span class="s">86400s</span><span class="p">;</span>
        <span class="kn">proxy_read_timeout</span> <span class="s">86400s</span><span class="p">;</span>

        <span class="c1"># don't write client body to docker file system</span>
        <span class="kn">proxy_request_buffering</span> <span class="no">off</span><span class="p">;</span>
    <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div></div> <p>création et push de l’image</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>docker-nginx-sidecar-tls
docker build <span class="nt">-t</span> thaidangfr/nginx-sidecar-tls:v1.0 <span class="nb">.</span>
docker push thaidangfr/nginx-sidecar-tls:v1.0
</code></pre></div></div> <h3 id="création-de-la-paire-de-clef-tls">Création de la paire de clef tls</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># create a self-signed certificate</span>
openssl req <span class="nt">-x509</span> <span class="nt">-newkey</span> rsa:2048 <span class="nt">-keyout</span> tls.key <span class="nt">-out</span> tls.crt <span class="nt">-nodes</span> <span class="nt">-subj</span> <span class="s1">'/CN=nginx-sidecar-tls-svc'</span>

<span class="c"># create a TLS secret</span>
kubectl create secret tls tls-cert <span class="nt">--cert</span><span class="o">=</span>tls.crt <span class="nt">--key</span><span class="o">=</span>tls.key
</code></pre></div></div> <h3 id="création-du-pod-et-du-service">Création du pod et du service</h3> <p>deploy.yaml</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">poc-sidecar-tls-deploy</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">poc-sidecar-tls</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">poc-sidecar-tls</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">1</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">poc-sidecar-tls</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">poc-sidecar-tls</span>
    <span class="na">spec</span><span class="pi">:</span>  
      <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">thaidangfr/nginx-hello-world:v1.0</span>
          <span class="na">imagePullPolicy</span><span class="pi">:</span> <span class="s">Always</span>
          <span class="na">ports</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">http-port</span>
              <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-tls</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">thaidangfr/nginx-sidecar-tls:v1.0</span>
          <span class="na">imagePullPolicy</span><span class="pi">:</span> <span class="s">Always</span>
          <span class="na">ports</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">https-port</span>
              <span class="na">containerPort</span><span class="pi">:</span> <span class="m">443</span>
          <span class="na">volumeMounts</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">tls-cert</span>
              <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/etc/nginx/ssl</span>              
      <span class="na">volumes</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">tls-cert</span>
          <span class="na">secret</span><span class="pi">:</span>
            <span class="na">secretName</span><span class="pi">:</span> <span class="s">tls-cert</span>
</code></pre></div></div> <p>svc.yaml</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">poc-sidecar-tls-svc</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">poc-sidecar-tls</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">poc-sidecar-tls</span>
  <span class="na">ports</span><span class="pi">:</span>    
    <span class="pi">-</span> <span class="na">port</span><span class="pi">:</span> <span class="m">443</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="s">https-port</span>
</code></pre></div></div> <p>installation du Deployment (qui va engendrer un ReplicaSet), puis du Service</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> deploy.yaml
kubectl apply <span class="nt">-f</span> svc.yaml
</code></pre></div></div> <h3 id="test">Test</h3> <p>on vérifie que l’on accède bien au serveur en https</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl proxy
curl http://localhost:8001/api/v1/namespaces/poc-sidecar-tls/services/https:poc-sidecar-tls-svc:443/proxy/
</code></pre></div></div>]]></content><author><name></name></author><category term="education"/><category term="tls"/><category term="sidecar"/><category term="kubernetes"/><summary type="html"><![CDATA[Utiliser un sidecar pour gérer le TLS avec des clefs existantes]]></summary></entry><entry><title type="html">Git tips</title><link href="https://dangconsulting.fr/blog/2024/git/" rel="alternate" type="text/html" title="Git tips"/><published>2024-06-17T12:00:00+00:00</published><updated>2024-06-17T12:00:00+00:00</updated><id>https://dangconsulting.fr/blog/2024/git</id><content type="html" xml:base="https://dangconsulting.fr/blog/2024/git/"><![CDATA[<h1 id="squash">Squash</h1> <p>Squasher ses commits git permet de factoriser ses commits avant de pusher son travail, histoire de partager un historique propre.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># lister tous les commits</span>
git log

<span class="c"># on va afficher les 5 derniers commits, le plus récent est en bas</span>
git rebase <span class="nt">-i</span> HEAD~5
</code></pre></div></div> <ul> <li>ceux que l’on souhaite factoriser, on va remplacer “pick” par “squash”</li> <li>sous emacs il faudra appuyer sur “s” puis “C-c C-c” pour valider puis mettre un commentaire puis “C-c C-c”</li> </ul>]]></content><author><name></name></author><category term="education"/><category term="git"/><summary type="html"><![CDATA[Trucs et astuces avec Git]]></summary></entry><entry><title type="html">Hashicorp Vault PKI Secret Engine</title><link href="https://dangconsulting.fr/blog/2024/vault-pki/" rel="alternate" type="text/html" title="Hashicorp Vault PKI Secret Engine"/><published>2024-06-15T12:00:00+00:00</published><updated>2024-06-15T12:00:00+00:00</updated><id>https://dangconsulting.fr/blog/2024/vault-pki</id><content type="html" xml:base="https://dangconsulting.fr/blog/2024/vault-pki/"><![CDATA[<h1 id="installer-un-client-vault-avec-asdf">Installer un client vault avec asdf</h1> <p>asdf permet d’installer des outils tiers sur une version précise à l’aide d’un système de plugins.</p> <p>exemple d’outils tiers : awscli, k0s, kubectl, terraform, trivy, vault, yq</p> <p>exemple avec vault</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>asdf plugin list          <span class="c"># list les plugin installés</span>
asdf update               <span class="c"># mise à jour de asdf</span>
asdf plugin update <span class="nt">--all</span>  <span class="c"># mise à jour de tous les plugins</span>


asdf plugin-add vault
asdf list all vault
asdf <span class="nb">install </span>vault 1.16.3 <span class="c"># install une version spécifique</span>

asdf global vault 1.16.3  <span class="c"># cette version sera dispo partout</span>
<span class="c">#asdf local vault 1.16.3  # =&gt; version dispo que dans le répertoire courant</span>
asdf current              <span class="c"># list les versions actuelles</span>


asdf plugin-update vault  <span class="c"># mise à jour du plugin vault</span>
</code></pre></div></div> <h1 id="curl-et-le-tls-sous-fedora">Curl et le TLS sous Fedora</h1> <p>Afin de pouvoir faire des curl vers des machines interne dont le TLS a été signé par votre PKI, il faut déployer votre Root CA sur votre desktop afin que celui-ci puisse le truster.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo cp</span> /mnt/secure/certificats/tls/ca.crt /etc/pki/ca-trust/source/anchors/dangconsulting-root-ca.crt
<span class="nb">sudo </span>update-ca-trust
</code></pre></div></div> <h1 id="pki-secret-engine">PKI Secret Engine</h1> <p>Le PKI Secret Engine de Vault permet de gérer une PKI interne.</p> <p>Il permet de :</p> <ul> <li>créer ou importer un Root CA</li> <li>créer un Intermediate CA</li> <li>appeler un role sur ce Intermediate CA afin de générer un certificat serveur</li> </ul> <p>Mais avant tout, il faut disposer de certains droits afin de pouvoir gérer la pki, donc nous allons créer une policy à associer au user gestionnaire.</p> <h3 id="créer-une-policy-à-associer-au-user-gestionnaire">Créer une policy à associer au user gestionnaire</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vault policy write pki - <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
# Enable secrets engine
path "sys/mounts/*" {
  capabilities = [ "create", "read", "update", "delete", "list" ]
}

# List enabled secrets engine
path "sys/mounts" {
  capabilities = [ "read", "list" ]
}

# Work with pki secrets engine
path "pki*" {
  capabilities = [ "create", "read", "update", "delete", "list", "sudo", "patch" ]
}
</span><span class="no">EOF

</span>vault policy <span class="nb">read </span>pki
</code></pre></div></div> <h3 id="import-dun-root-ca-déjà-existante">Import d’un Root CA déjà existante</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vault secrets <span class="nb">enable</span> <span class="nt">-path</span><span class="o">=</span>pki_root pki
vault secrets tune <span class="nt">-max-lease-ttl</span><span class="o">=</span>87600h pki_root
vault write pki_root/config/urls <span class="nv">issuing_certificates</span><span class="o">=</span><span class="s2">"https://vault.home/v1/pki_root/ca"</span> <span class="nv">crl_distribution_points</span><span class="o">=</span><span class="s2">"https://vault.home/v1/pki_root/crl"</span>
vault write pki_root/config/crl <span class="nv">auto_rebuild</span><span class="o">=</span><span class="nb">true

</span>vault write <span class="nt">-format</span><span class="o">=</span>json pki_root/config/ca <span class="nv">pem_bundle</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">cat</span> /mnt/secure/certificats/tls/ca.crt /mnt/secure/certificats/tls/ca.key<span class="si">)</span><span class="s2">"</span>
vault list pki_root/issuers/
</code></pre></div></div> <h3 id="création-dun-intermediate-ca">Création d’un Intermediate CA</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vault secrets <span class="nb">enable</span> <span class="nt">-path</span><span class="o">=</span>pki_intermediate pki
vault secrets tune <span class="nt">-max-lease-ttl</span><span class="o">=</span>43800h pki_intermediate
vault write pki_intermediate/config/urls <span class="nv">issuing_certificates</span><span class="o">=</span><span class="s2">"https://vault.home/v1/pki_intermediate/ca"</span> <span class="nv">crl_distribution_points</span><span class="o">=</span><span class="s2">"https://vault.home/v1/pki_intermediate/crl"</span>
vault write pki_intermediate/config/crl <span class="nv">auto_rebuild</span><span class="o">=</span><span class="nb">true</span>

<span class="c"># create csr</span>
vault write <span class="nt">-format</span><span class="o">=</span>json pki_intermediate/intermediate/generate/internal <span class="se">\</span>
     <span class="nv">common_name</span><span class="o">=</span><span class="s2">"Intermediate CA"</span> <span class="se">\</span>
     | jq <span class="nt">-r</span> <span class="s1">'.data.csr'</span> <span class="o">&gt;</span> pki_intermediate.csr

<span class="c"># create crt and sign it with root ca</span>
vault write <span class="nt">-format</span><span class="o">=</span>json pki_root/root/sign-intermediate <span class="se">\</span>
     <span class="nv">csr</span><span class="o">=</span>@pki_intermediate.csr <span class="se">\</span>
     <span class="nv">format</span><span class="o">=</span>pem_bundle <span class="nv">ttl</span><span class="o">=</span><span class="s2">"43800h"</span> <span class="se">\</span>
     | jq <span class="nt">-r</span> <span class="s1">'.data.certificate'</span> <span class="o">&gt;</span> intermediate.cert.pem

<span class="c"># import the intermediate certificate</span>
vault write pki_intermediate/intermediate/set-signed <span class="nv">certificate</span><span class="o">=</span>@intermediate.cert.pem
<span class="nb">rm</span> <span class="nt">-f</span> pki_intermediate.csr intermediate.cert.pem 

vault list pki_intermediate/issuers/
</code></pre></div></div> <h3 id="création-dun-role-et-génération-de-certificat-serveur">Création d’un role et génération de certificat serveur</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># create role (add no_store=true if you don't want to store all the issued certificates)</span>
vault write pki_intermediate/roles/home <span class="nv">allowed_domains</span><span class="o">=</span>home <span class="nv">allow_subdomains</span><span class="o">=</span><span class="nb">true </span><span class="nv">max_ttl</span><span class="o">=</span>720h <span class="nv">no_store</span><span class="o">=</span><span class="nb">true</span> 

<span class="c"># generate a server certificate by calling the role</span>
<span class="c"># output will contain : ca_chain, certificate, issuing_ca, private_key, private_key_type, serial_number</span>
vault write pki_intermediate/issue/home <span class="nv">common_name</span><span class="o">=</span>toto.home <span class="nv">ttl</span><span class="o">=</span><span class="s2">"5m"</span>   <span class="c"># available only during 5min</span>
</code></pre></div></div> <h3 id="lister-les-certificats-créés-afficher-des-détails-ou-le-télécharger">Lister les certificats créés, afficher des détails ou le télécharger</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># return a list of serial_number</span>
vault list pki_intermediate/certs

<span class="c"># get details on the certificate</span>
vault <span class="nb">read </span>pki_intermediate/cert/&lt;serial_number&gt;

<span class="c"># download a certificate</span>
vault <span class="nb">read</span> <span class="nt">-field</span><span class="o">=</span>certificate pki_intermediate/cert/&lt;serial_number&gt; <span class="o">&gt;</span> toto.home.crt
</code></pre></div></div> <h3 id="révoquer-un-certificat">Révoquer un certificat</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vault write pki_intermediate/revoke <span class="nv">serial_number</span><span class="o">=</span>&lt;serial_number&gt;
</code></pre></div></div> <h3 id="maintenance-des-issuers-et-des-certificats">Maintenance des issuers et des certificats</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># manually delete expired certificates, with low safety_buffer to make it happen quickly</span>
vault write pki_intermediate/tidy <span class="nv">tidy_cert_store</span><span class="o">=</span><span class="nb">true </span><span class="nv">tidy_revoked_certs</span><span class="o">=</span><span class="nb">true </span><span class="nv">safety_buffer</span><span class="o">=</span><span class="s2">"1m"</span>

<span class="c"># activate the automatic tidy of expired certificates or issuers</span>
vault write pki_intermediate/config/auto-tidy <span class="nv">enabled</span><span class="o">=</span><span class="nb">true </span><span class="nv">tidy_expired_issuers</span><span class="o">=</span><span class="nb">true </span><span class="nv">tidy_revoked_cert_issuer_associations</span><span class="o">=</span><span class="nb">true </span><span class="nv">tidy_cert_store</span><span class="o">=</span><span class="nb">true </span><span class="nv">tidy_revoked_certs</span><span class="o">=</span><span class="nb">true </span><span class="nv">safety_buffer</span><span class="o">=</span>10m

<span class="c"># status of tidy</span>
vault <span class="nb">read </span>pki_intermediate/tidy-status
</code></pre></div></div> <h2 id="vérifier-le-crl-après-la-révocation">Vérifier le CRL après la révocation</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># download the chain ca (intermediate + root concatened)</span>
<span class="c"># curl https://vault.home/v1/pki_root/ca_chain &gt; root.crt     # to have only the root</span>
curl https://vault.home/v1/pki_intermediate/ca_chain <span class="o">&gt;</span> chain-ca.pem

<span class="c"># download server certificate</span>
vault list pki_intermediate/certs
vault <span class="nb">read</span> <span class="nt">-field</span><span class="o">=</span>certificate pki_intermediate/cert/&lt;serial_number&gt; <span class="o">&gt;</span> toto.home.crt

<span class="c"># manually update CRL</span>
vault <span class="nb">read </span>pki_intermediate/crl/rotate

<span class="c"># check CRL</span>
curl https://vault.home/v1/pki_intermediate/crl <span class="nt">-o</span> crl.der
openssl crl <span class="nt">-in</span> crl.der <span class="nt">-text</span>
openssl crl <span class="nt">-inform</span> DER <span class="nt">-in</span> crl.der <span class="nt">-outform</span> PEM <span class="nt">-out</span> crl.pem

openssl verify <span class="nt">-crl_check_all</span> <span class="nt">-CRLfile</span> crl.pem <span class="nt">-CAfile</span> chain-ca.pem toto.home.crt   <span class="c"># =&gt; certificate revoked</span>
</code></pre></div></div> <h1 id="références">Références</h1> <ul> <li><a href="https://docs.tetrate.io/service-bridge/1.5.x/setup/certificate/external-ca/vault">Import external Root CA</a></li> <li><a href="https://developer.hashicorp.com/vault/tutorials/secrets-management/pki-engine">Official Vault PKI tutorial</a></li> <li><a href="https://developer.hashicorp.com/vault/api-docs/secret/pki">API docs for Vault PKI</a></li> </ul>]]></content><author><name></name></author><category term="education"/><category term="vault"/><summary type="html"><![CDATA[Comment gérer une PKI interne avec Vault]]></summary></entry></feed>